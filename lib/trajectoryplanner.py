import numpy as np
import time


class QuinticTrajectoryPlanner():
    """
    Generate a quintic polynomial trajectory
    paramteres accepted : 
    """
    def __init__(self, start_pos, des_pos,T,start_vel=[0,0,0], des_vel=[0,0,0], start_acc=[0,0,0], des_acc=[0,0,0], dt = 0.1, logger=False, precision = 4):

        self.logger = logger
        self.precision = precision

        self.start_x = start_pos[0]
        self.start_y = start_pos[1]
        self.start_z = start_pos[2]

        self.des_x = des_pos[0]
        self.des_y = des_pos[1]
        self.des_z = des_pos[2]

        self.start_x_vel = start_vel[0]
        self.start_y_vel = start_vel[1]
        self.start_z_vel = start_vel[2]

        self.des_x_vel = des_vel[0]
        self.des_y_vel = des_vel[1]
        self.des_z_vel = des_vel[2]

        self.start_x_acc = start_acc[0]
        self.start_y_acc = start_acc[1]
        self.start_z_acc = start_acc[2]

        self.des_x_acc = des_acc[0]
        self.des_y_acc = des_acc[1]
        self.des_z_acc = des_acc[2]

        self.is_coeff_solved = False

        self.T = T
        self.dt = dt
        self.t = 0

        self.x_pos = []
        self.y_pos = []
        self.z_pos = []
        
        self.x_vel = []
        self.y_vel = []
        self.z_vel = []

        self.x_acc = []
        self.y_acc = []
        self.z_acc = []

        self.t_stamp = []

        if self.logger:
            print(f'Start Point : {start_pos} End Point : {des_pos}')

        self.__solve_coef()

    def __solve_coef(self):
        """
        Find quintic coefficients based on wapoints, velocity and acceleration
        """
        A = np.array(
            [[0, 0, 0, 0, 0, 1],
             [self.T**5, self.T**4, self.T**3, self.T**2, self.T, 1],
             [0, 0, 0, 0, 1, 0],
             [5*self.T**4, 4*self.T**3, 3*self.T**2, 2*self.T, 1, 0],
             [0, 0, 0, 2, 0, 0],
             [20*self.T**3, 12*self.T**2, 6*self.T, 2, 0, 0]
            ])

        b_x = np.array(
            [[self.start_x],
             [self.des_x],
             [self.start_x_vel],
             [self.des_x_vel],
             [self.start_x_acc],
             [self.des_x_acc]
            ])

        b_y = np.array(
            [[self.start_y],
             [self.des_y],
             [self.start_y_vel],
             [self.des_y_vel],
             [self.start_y_acc],
             [self.des_y_acc]
            ])

        b_z = np.array(
            [[self.start_z],
             [self.des_z],
             [self.start_z_vel],
             [self.des_z_vel],
             [self.start_z_acc],
             [self.des_z_acc]
            ])

        self.x_c = np.linalg.solve(A, b_x)
        self.y_c = np.linalg.solve(A, b_y)
        self.z_c = np.linalg.solve(A, b_z)

        self.is_coeff_solved = True

    def __calculate_position(self,c, t):
        """
        Calculates a position given a set of quintic coefficients and a time.

        Args
            c: List of coefficients generated by a quintic polynomial 
                trajectory generator.
            t: Time at which to calculate the position

        Returns
            Position
        """
        return round(float(c[0] * t**5 + c[1] * t**4 + c[2] * t**3 + c[3] * t**2 + c[4] * t + c[5]),self.precision)


    def __calculate_velocity(self,c, t):
        """
        Calculates a velocity given a set of quintic coefficients and a time.

        Args
            c: List of coefficients generated by a quintic polynomial 
                trajectory generator.
            t: Time at which to calculate the velocity

        Returns
            Velocity
        """
        return round(float(5 * c[0] * t**4 + 4 * c[1] * t**3 + 3 * c[2] * t**2 + 2 * c[3] * t + c[4]),self.precision)


    def __calculate_acceleration(self,c, t):
        """
        Calculates an acceleration given a set of quintic coefficients and a time.

        Args
            c: List of coefficients generated by a quintic polynomial 
                trajectory generator.
            t: Time at which to calculate the acceleration

        Returns
            Acceleration
        """
        return round(float(20 * c[0] * t**3 + 12 * c[1] * t**2 + 6 * c[2] * t + 2 * c[3]),self.precision)

    def solve(self):
        """"
        Calculate the necessary poitions, velocities and acceleraton
        """
        if not self.is_coeff_solved:
            print("Solve coefficients first")
            return

        while self.t <= self.T:
            x_pos = self.__calculate_position(self.x_c, self.t)
            y_pos = self.__calculate_position(self.y_c, self.t)
            z_pos = self.__calculate_position(self.z_c, self.t)
            x_vel = self.__calculate_velocity(self.x_c, self.t)
            y_vel = self.__calculate_velocity(self.y_c, self.t)
            z_vel = self.__calculate_velocity(self.z_c, self.t)
            x_acc = self.__calculate_acceleration(self.x_c, self.t)
            y_acc = self.__calculate_acceleration(self.y_c, self.t)
            z_acc = self.__calculate_acceleration(self.z_c, self.t)

            self.x_pos.append(x_pos)
            self.y_pos.append(y_pos)
            self.z_pos.append(z_pos)

            self.x_vel.append(x_vel)
            self.y_vel.append(y_vel)
            self.z_vel.append(z_vel)
            
            self.x_acc.append(x_acc)
            self.y_acc.append(y_acc)
            self.z_acc.append(z_acc)

            if self.logger:
                print(f'x : {x_pos} x_vel : {x_vel} y_pos : {y_pos} y_vel : {y_vel} z_pos : {z_pos} z_vel : {z_vel}')
                time.sleep(0.1)

            self.t_stamp.append(self.t)

            self.t += self.dt

class ErrorController():
    def __init__(self):
        pass